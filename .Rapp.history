rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))
dim(mcmc_samples$Sigma)
rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
nburn=c(1:5999)#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))
dim(mcmc_samples$Sigma)
rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
nburn=c(1:5998)#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))
dim(mcmc_samples$Sigma)
rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
nburn=c(1:10)#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))
dim(mcmc_samples$Sigma)
rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.99))#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))
dim(mcmc_samples$Sigma)
dim(mcmc_samples$Beta)
dim(mcmc_samples$beta)
log(det(par_t$Sigma[1,,]))
par_t<-mcmc_samples#
dens <- sum(network, na.rm=TRUE)/(N^2 - N)#
b0=1#
a0=(b0*(10*dens))/(1-(10*dens))
K <- length(par_t$pi)#
  d <- ncol(par_t$Z)#
  cD <- 2 * gamma((d+1)/2) / gamma(d/2)#
  pi_ll <- sum(par_t$block_n * log(par_t$pi))#
  Yoff_ll <- sum(par_t$s[lower.tri(par_t$s, diag=FALSE)] * log(par_t$B[lower.tri(par_t$B, diag=FALSE)]))
theta <- cbind(par_t$beta, log(par_t$sigma))
theta_ll <- - K * log(2*3.1415)- (K/2) * log(det(par_t$Sigma[1,,])) + sum(apply(theta, 1, function(thetak) - .5 * t(thetak - par_t$mu) %*% solve(par_t$Sigma) %*% (thetak - par_t$mu)))
par_t$Sigma[1,,]
det(par_t$Sigma[1,,])
theta_ll <- - K * log(2*3.1415)- (K/2) * log(det(par_t$Sigma[1,,])) + sum(apply(theta, 1, function(thetak) - .5 * t(thetak - par_t$mu) %*% solve(par_t$Sigma[1,,]) %*% (thetak - par_t$mu)))
sum(apply(theta, 1, function(thetak)
- .5 * t(thetak - par_t$mu)
%*% solve(par_t$Sigma[1,,]) %*% (thetak - par_t$mu)))
sum(apply(theta, 1, function(thetak) - .5 * t(thetak - par_t$mu) %*% solve(par_t$Sigma[1,,]) %*% (thetak - par_t$mu))
)
olve(par_t$Sigma[1,,])
solve(par_t$Sigma[1,,])
t(thetak - par_t$mu)
dim(theta)
par_t$sigma
dim(par_t$Sigma)
dim(par_t$sigma)
rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
nburn=c(1:5999)#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))
mcmc_samples$beta
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
nburn=c(1:5998)#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))
mcmc_samples$beta
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
nburn=c(1:1999)#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))
mcmc_samples$beta
abind(mcmc_samplesc1$Sigma[1,,], along=1)
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[1,]),#
                sigma=rbind(mcmc_samplesc1$sigma[1,]),#
                 pi=rbind(mcmc_samplesc1$pi[1,]),#
                 mu=rbind(mcmc_samplesc1$mu[1,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[1,,], along=1),#
                 B=abind(mcmc_samplesc1$B[1,,],along=1),#
                 Z=abind(mcmc_samplesc1$Z[1,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[1,]))
par_t<-mcmc_samples#
dens <- sum(network, na.rm=TRUE)/(N^2 - N)#
b0=1#
a0=(b0*(10*dens))/(1-(10*dens))
a=log_likelihood(network,mcmc_samples,alpha0=.1, a0=a0, b0=b0, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1)
K <- length(par_t$pi)#
  d <- ncol(par_t$Z)#
  cD <- 2 * gamma((d+1)/2) / gamma(d/2)#
  pi_ll <- sum(par_t$block_n * log(par_t$pi))
Yoff_ll <- sum(par_t$s[lower.tri(par_t$s, diag=FALSE)] * log(par_t$B[lower.tri(par_t$B, diag=FALSE)]))
theta <- cbind(par_t$beta, log(par_t$sigma))
theta_ll <- - K * log(2*3.1415)- (K/2) * log(det(par_t$Sigma)) + sum(apply(theta, 1, function(thetak) - .5 * t(thetak - par_t$mu) %*% solve(par_t$Sigma) %*% (thetak - par_t$mu)))
par_t$mu
par_t$mu
dim(theta)
log(par_t$sigma)
par_t$beta
dim(theta)
theta
par_t$mu
dim(mcmc_samplesc1$mu)
log(det(par_t$Sigma))
theta <- cbind(par_t$beta, log(par_t$sigma))
theta
par_t$beta
log(par_t$sigma)
theta <- cbind(as.vector(par_t$beta), as.vector(log(par_t$sigma)))
dim(theta)
theta
thetak - par_t$mu
theta_ll <- - K * log(2*3.1415)- (K/2) * log(det(par_t$Sigma)) + sum(apply(theta, 1, function(thetak) - .5 * t(thetak - par_t$mu) %*% solve(par_t$Sigma) %*% (thetak - par_t$mu)))
theta[1,]
theta[1,]-par_t$mu
solve(par_t$Sigma)
thetak=theta[1,]
t(thetak - par_t$mu)
t(thetak - par_t$mu) %*% solve(par_t$Sigma) %*%
(thetak - par_t$mu)
(thetak - par_t$mu)
(thetak - par_t$mu) %*% solve(par_t$Sigma)
rm(thetak)
theta_ll <- - K * log(2*3.1415)- (K/2) * log(det(par_t$Sigma)) + sum(apply(theta, 1, function(thetak) - .5 * (thetak - par_t$mu) %*% solve(par_t$Sigma) %*% t(thetak - par_t$mu)))
Ydiag_ll <- z_ll <- 0
for(k in 1:K) {#
    k_membs <- which(par_t$gamma == k) #
    etak <- par_t$beta[k] - par_t$dists[[k]]#
    mat <- Y[k_membs, k_membs] * etak - log1p(exp(etak))#
    Ydiag_ll <- Ydiag_ll + sum(mat[lower.tri(mat, diag=FALSE)]) #
    z_ll <- z_ll+ sum(dnorm(c(par_t$Z[k_membs,]), 0, par_t$sigma[k], log=TRUE))#
  }
Y=network
for(k in 1:K) {#
    k_membs <- which(par_t$gamma == k) #
    etak <- par_t$beta[k] - par_t$dists[[k]]#
    mat <- Y[k_membs, k_membs] * etak - log1p(exp(etak))#
    Ydiag_ll <- Ydiag_ll + sum(mat[lower.tri(mat, diag=FALSE)]) #
    z_ll <- z_ll+ sum(dnorm(c(par_t$Z[k_membs,]), 0, par_t$sigma[k], log=TRUE))#
  }
piprior_ll <- sum(log(ddirichlet(par_t$pi, rep(alpha0, K))))#
  Bprior_ll <- sum(log(dbeta(par_t$B[lower.tri(par_t$B, diag=FALSE)], a0, b0)))
alpha0=.1
piprior_ll <- sum(log(ddirichlet(par_t$pi, rep(alpha0, K))))#
  Bprior_ll <- sum(log(dbeta(par_t$B[lower.tri(par_t$B, diag=FALSE)], a0, b0)))
a0=a0
b0=b0
m0=c(0,0)
s0=0.01
psi0=matrix(c(5.1,0,0,5.1), nrow=2)
nu0=5.1
muprior_ll <- - log(2*3.1415) - (1/2) * log(det(par_t$Sigma/ s0)) - (1/2) * t(par_t$mu - m0) %*% solve(par_t$Sigma / s0) %*% (par_t$mu - m0)
muprior_ll <- - log(2*3.1415) - (1/2) * log(det(par_t$Sigma/ s0)) - (1/2) * (par_t$mu - m0) %*% solve(par_t$Sigma / s0) %*% t(par_t$mu - m0)
Sigmaprior_ll <- log(diwish(par_t$Sigma, nu0, psi0))
c(Ydiag_ll=Ydiag_ll, Yoff_ll=Yoff_ll, pi_ll=pi_ll, z_ll, theta_ll=theta_ll, piprior_ll=piprior_ll, Bprior_ll=Bprior_ll, muprior_ll=muprior_ll, Sigmaprior_ll=Sigmaprior_ll)
a=c(Ydiag_ll=Ydiag_ll, Yoff_ll=Yoff_ll, pi_ll=pi_ll, z_ll=z_ll, theta_ll=theta_ll, piprior_ll=piprior_ll, Bprior_ll=Bprior_ll, muprior_ll=muprior_ll, Sigmaprior_ll=Sigmaprior_ll)
sum(a)
component_lls=c(Ydiag_ll=Ydiag_ll, Yoff_ll=Yoff_ll, pi_ll=pi_ll, z_ll=z_ll, theta_ll=theta_ll, piprior_ll=piprior_ll, Bprior_ll=Bprior_ll, muprior_ll=muprior_ll, Sigmaprior_ll=Sigmaprior_ll)#
  sum(component_lls)
rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))
# ## and have results and have post-processed them with India_village_postprocess.R.  #
# ##
# ##
# # Author: tedwestling#
# ################################################################################
 rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))#
#
#block_latent_MCMC <- function(Y, D, K, burn_in, n_samples, thin, v, epsilon=.1, rZ=1, Atheta=matrix(c(2,1,1,1), nrow=2), alpha0=.1, a0=NULL, b0=NULL, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1, verbose=TRUE, memb_start=NULL, plot_init=FALSE, likelihood=FALSE, true_gamma=NULL, postprocess=TRUE, sample_membs=TRUE, record_acc_probs=FALSE, debug_output=FALSE, perturb_init=TRUE) {#
	#log_likelihood=function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[1,]),#
                sigma=rbind(mcmc_samplesc1$sigma[1,]),#
                 pi=rbind(mcmc_samplesc1$pi[1,]),#
                 mu=rbind(mcmc_samplesc1$mu[1,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[1,,], along=1),#
                 B=abind(mcmc_samplesc1$B[1,,],along=1),#
                 Z=abind(mcmc_samplesc1$Z[1,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[1,]))
log_likelihood <- function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {#
  K <- length(par_t$pi)#
  d <- ncol(par_t$Z)#
  cD <- 2 * gamma((d+1)/2) / gamma(d/2)#
  pi_ll <- sum(par_t$block_n * log(par_t$pi))#
  Yoff_ll <- sum(par_t$s[lower.tri(par_t$s, diag=FALSE)] * log(par_t$B[lower.tri(par_t$B, diag=FALSE)]))#
  theta <- cbind(as.vector(par_t$beta), as.vector(log(par_t$sigma)))#
  theta_ll <- - K * log(2*3.1415)- (K/2) * log(det(par_t$Sigma)) + sum(apply(theta, 1, function(thetak) - .5 * (thetak - par_t$mu) %*% solve(par_t$Sigma) %*% t(thetak - par_t$mu)))#
  Ydiag_ll <- z_ll <- 0#
  for(k in 1:K) {#
    k_membs <- which(par_t$gamma == k) #
    etak <- par_t$beta[k] - par_t$dists[[k]]#
    mat <- Y[k_membs, k_membs] * etak - log1p(exp(etak))#
    Ydiag_ll <- Ydiag_ll + sum(mat[lower.tri(mat, diag=FALSE)]) #
    z_ll <- z_ll+ sum(dnorm(c(par_t$Z[k_membs,]), 0, par_t$sigma[k], log=TRUE))#
  }#
  piprior_ll <- sum(log(ddirichlet(par_t$pi, rep(alpha0, K))))#
  Bprior_ll <- sum(log(dbeta(par_t$B[lower.tri(par_t$B, diag=FALSE)], a0, b0)))#
  muprior_ll <- - log(2*3.1415) - (1/2) * log(det(par_t$Sigma/ s0)) - (1/2) * (par_t$mu - m0) %*% solve(par_t$Sigma / s0) %*% t(par_t$mu - m0)#
  Sigmaprior_ll <- log(diwish(par_t$Sigma, nu0, psi0))#
  component_lls=c(Ydiag_ll=Ydiag_ll, Yoff_ll=Yoff_ll, pi_ll=pi_ll, z_ll=z_ll, theta_ll=theta_ll, piprior_ll=piprior_ll, Bprior_ll=Bprior_ll, muprior_ll=muprior_ll, Sigmaprior_ll=Sigmaprior_ll)#
  sum(component_lls)#
}
par_t<-mcmc_samples
dens <- sum(network, na.rm=TRUE)/(N^2 - N)#
b0=1#
a0=(b0*(10*dens))/(1-(10*dens))
a=log_likelihood(network,mcmc_samples,alpha0=.1, a0=a0, b0=b0, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1)
a
postprob=rep(NA,nrow(mcmc_samples$beta))
dim(postprob)
length(postprob)
nrow(mcmc_samples$beta)
nrow(mcmc_samples$beta)
nchains
ls()
dim(mcmc_samplesc1$beta)
ii-4500
ii=4500
mcmc_samples_tmp <- list(beta=rbind(mcmc_samples$beta[ii,]),#
                sigma=rbind(mcmc_samples$sigma[ii,]),#
                 pi=rbind(mcmc_samples$pi[ii,]),#
                 mu=rbind(mcmc_samples$mu[ii,]),#
                 Sigma=abind(mcmc_samples$Sigma[ii,,], along=1),#
                 B=abind(mcmc_samples$B[ii,,],along=1),#
                 Z=abind(mcmc_samples$Z[ii,,], along=1),#
                 gamma=rbind(mcmc_samples$gamma[ii,]))
rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))
log_likelihood <- function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {#
  K <- length(par_t$pi)#
  d <- ncol(par_t$Z)#
  cD <- 2 * gamma((d+1)/2) / gamma(d/2)#
  pi_ll <- sum(par_t$block_n * log(par_t$pi))#
  Yoff_ll <- sum(par_t$s[lower.tri(par_t$s, diag=FALSE)] * log(par_t$B[lower.tri(par_t$B, diag=FALSE)]))#
  theta <- cbind(as.vector(par_t$beta), as.vector(log(par_t$sigma)))#
  theta_ll <- - K * log(2*3.1415)- (K/2) * log(det(par_t$Sigma)) + sum(apply(theta, 1, function(thetak) - .5 * (thetak - par_t$mu) %*% solve(par_t$Sigma) %*% t(thetak - par_t$mu)))#
  Ydiag_ll <- z_ll <- 0#
  for(k in 1:K) {#
    k_membs <- which(par_t$gamma == k) #
    etak <- par_t$beta[k] - par_t$dists[[k]]#
    mat <- Y[k_membs, k_membs] * etak - log1p(exp(etak))#
    Ydiag_ll <- Ydiag_ll + sum(mat[lower.tri(mat, diag=FALSE)]) #
    z_ll <- z_ll+ sum(dnorm(c(par_t$Z[k_membs,]), 0, par_t$sigma[k], log=TRUE))#
  }#
  piprior_ll <- sum(log(ddirichlet(par_t$pi, rep(alpha0, K))))#
  Bprior_ll <- sum(log(dbeta(par_t$B[lower.tri(par_t$B, diag=FALSE)], a0, b0)))#
  muprior_ll <- - log(2*3.1415) - (1/2) * log(det(par_t$Sigma/ s0)) - (1/2) * (par_t$mu - m0) %*% solve(par_t$Sigma / s0) %*% t(par_t$mu - m0)#
  Sigmaprior_ll <- log(diwish(par_t$Sigma, nu0, psi0))#
  component_lls=c(Ydiag_ll=Ydiag_ll, Yoff_ll=Yoff_ll, pi_ll=pi_ll, z_ll=z_ll, theta_ll=theta_ll, piprior_ll=piprior_ll, Bprior_ll=Bprior_ll, muprior_ll=muprior_ll, Sigmaprior_ll=Sigmaprior_ll)#
  sum(component_lls)#
}
dens <- sum(network, na.rm=TRUE)/(N^2 - N)#
b0=1#
a0=(b0*(10*dens))/(1-(10*dens))
dim(mcmc_samples$beta)
ii=4500
mcmc_samples_tmp <- list(beta=rbind(mcmc_samples$beta[ii,]),#
                sigma=rbind(mcmc_samples$sigma[ii,]),#
                 pi=rbind(mcmc_samples$pi[ii,]),#
                 mu=rbind(mcmc_samples$mu[ii,]),#
                 Sigma=abind(mcmc_samples$Sigma[ii,,], along=1),#
                 B=abind(mcmc_samples$B[ii,,],along=1),#
                 Z=abind(mcmc_samples$Z[ii,,], along=1),#
                 gamma=rbind(mcmc_samples$gamma[ii,]))
par_t<-mcmc_samples_tmp
postprob=rep(NA,nrwo(mcmc_samples$beta))
postprob=rep(NA,nrow(mcmc_samples$beta))
postprob[ii]=log_likelihood(network,mcmc_samples_tmp,alpha0=.1, a0=a0, b0=b0, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1)
ii**100
ii%%100)
ii%%100
4501%%100
9500%%100
# ################################################################################
# # Multi-resolution blockmodel#
# ##
# # file: indian_village_figures.R#
# # #
# # This file makes the plots for the paper.  Assuming that we have already run India_village_estimation.R#
# ## and have results and have post-processed them with India_village_postprocess.R.  #
# ##
# ##
# # Author: tedwestling#
# ################################################################################
 rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))#
#
#block_latent_MCMC <- function(Y, D, K, burn_in, n_samples, thin, v, epsilon=.1, rZ=1, Atheta=matrix(c(2,1,1,1), nrow=2), alpha0=.1, a0=NULL, b0=NULL, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1, verbose=TRUE, memb_start=NULL, plot_init=FALSE, likelihood=FALSE, true_gamma=NULL, postprocess=TRUE, sample_membs=TRUE, record_acc_probs=FALSE, debug_output=FALSE, perturb_init=TRUE) {#
	#log_likelihood=function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {#
log_likelihood <- function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {#
  K <- length(par_t$pi)#
  d <- ncol(par_t$Z)#
  cD <- 2 * gamma((d+1)/2) / gamma(d/2)#
  pi_ll <- sum(par_t$block_n * log(par_t$pi))#
  Yoff_ll <- sum(par_t$s[lower.tri(par_t$s, diag=FALSE)] * log(par_t$B[lower.tri(par_t$B, diag=FALSE)]))#
  theta <- cbind(as.vector(par_t$beta), as.vector(log(par_t$sigma)))#
  theta_ll <- - K * log(2*3.1415)- (K/2) * log(det(par_t$Sigma)) + sum(apply(theta, 1, function(thetak) - .5 * (thetak - par_t$mu) %*% solve(par_t$Sigma) %*% t(thetak - par_t$mu)))#
  Ydiag_ll <- z_ll <- 0#
  for(k in 1:K) {#
    k_membs <- which(par_t$gamma == k) #
    etak <- par_t$beta[k] - par_t$dists[[k]]#
    mat <- Y[k_membs, k_membs] * etak - log1p(exp(etak))#
    Ydiag_ll <- Ydiag_ll + sum(mat[lower.tri(mat, diag=FALSE)]) #
    z_ll <- z_ll+ sum(dnorm(c(par_t$Z[k_membs,]), 0, par_t$sigma[k], log=TRUE))#
  }#
  piprior_ll <- sum(log(ddirichlet(par_t$pi, rep(alpha0, K))))#
  Bprior_ll <- sum(log(dbeta(par_t$B[lower.tri(par_t$B, diag=FALSE)], a0, b0)))#
  muprior_ll <- - log(2*3.1415) - (1/2) * log(det(par_t$Sigma/ s0)) - (1/2) * (par_t$mu - m0) %*% solve(par_t$Sigma / s0) %*% t(par_t$mu - m0)#
  Sigmaprior_ll <- log(diwish(par_t$Sigma, nu0, psi0))#
  component_lls=c(Ydiag_ll=Ydiag_ll, Yoff_ll=Yoff_ll, pi_ll=pi_ll, z_ll=z_ll, theta_ll=theta_ll, piprior_ll=piprior_ll, Bprior_ll=Bprior_ll, muprior_ll=muprior_ll, Sigmaprior_ll=Sigmaprior_ll)#
  sum(component_lls)#
}#
dens <- sum(network, na.rm=TRUE)/(N^2 - N)#
b0=1#
a0=(b0*(10*dens))/(1-(10*dens))#
#
postprob=rep(NA,nrow(mcmc_samples$beta))#
for(ii in 1:nrwo(mcmc_samples$beta)){#
	mcmc_samples_tmp <- list(beta=rbind(mcmc_samples$beta[ii,]),#
                sigma=rbind(mcmc_samples$sigma[ii,]),#
                 pi=rbind(mcmc_samples$pi[ii,]),#
                 mu=rbind(mcmc_samples$mu[ii,]),#
                 Sigma=abind(mcmc_samples$Sigma[ii,,], along=1),#
                 B=abind(mcmc_samples$B[ii,,],along=1),#
                 Z=abind(mcmc_samples$Z[ii,,], along=1),#
                 gamma=rbind(mcmc_samples$gamma[ii,]))#
	par_t<-mcmc_samples_tmp#
if(ii%%100==0){print(ii)}#
postprob[ii]=log_likelihood(network,mcmc_samples_tmp,alpha0=.1, a0=a0, b0=b0, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1)#
}
# ################################################################################
# # Multi-resolution blockmodel#
# ##
# # file: indian_village_figures.R#
# # #
# # This file makes the plots for the paper.  Assuming that we have already run India_village_estimation.R#
# ## and have results and have post-processed them with India_village_postprocess.R.  #
# ##
# ##
# # Author: tedwestling#
# ################################################################################
 rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))#
#
#block_latent_MCMC <- function(Y, D, K, burn_in, n_samples, thin, v, epsilon=.1, rZ=1, Atheta=matrix(c(2,1,1,1), nrow=2), alpha0=.1, a0=NULL, b0=NULL, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1, verbose=TRUE, memb_start=NULL, plot_init=FALSE, likelihood=FALSE, true_gamma=NULL, postprocess=TRUE, sample_membs=TRUE, record_acc_probs=FALSE, debug_output=FALSE, perturb_init=TRUE) {#
	#log_likelihood=function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {#
log_likelihood <- function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {#
  K <- length(par_t$pi)#
  d <- ncol(par_t$Z)#
  cD <- 2 * gamma((d+1)/2) / gamma(d/2)#
  pi_ll <- sum(par_t$block_n * log(par_t$pi))#
  Yoff_ll <- sum(par_t$s[lower.tri(par_t$s, diag=FALSE)] * log(par_t$B[lower.tri(par_t$B, diag=FALSE)]))#
  theta <- cbind(as.vector(par_t$beta), as.vector(log(par_t$sigma)))#
  theta_ll <- - K * log(2*3.1415)- (K/2) * log(det(par_t$Sigma)) + sum(apply(theta, 1, function(thetak) - .5 * (thetak - par_t$mu) %*% solve(par_t$Sigma) %*% t(thetak - par_t$mu)))#
  Ydiag_ll <- z_ll <- 0#
  for(k in 1:K) {#
    k_membs <- which(par_t$gamma == k) #
    etak <- par_t$beta[k] - par_t$dists[[k]]#
    mat <- Y[k_membs, k_membs] * etak - log1p(exp(etak))#
    Ydiag_ll <- Ydiag_ll + sum(mat[lower.tri(mat, diag=FALSE)]) #
    z_ll <- z_ll+ sum(dnorm(c(par_t$Z[k_membs,]), 0, par_t$sigma[k], log=TRUE))#
  }#
  piprior_ll <- sum(log(ddirichlet(par_t$pi, rep(alpha0, K))))#
  Bprior_ll <- sum(log(dbeta(par_t$B[lower.tri(par_t$B, diag=FALSE)], a0, b0)))#
  muprior_ll <- - log(2*3.1415) - (1/2) * log(det(par_t$Sigma/ s0)) - (1/2) * (par_t$mu - m0) %*% solve(par_t$Sigma / s0) %*% t(par_t$mu - m0)#
  Sigmaprior_ll <- log(diwish(par_t$Sigma, nu0, psi0))#
  component_lls=c(Ydiag_ll=Ydiag_ll, Yoff_ll=Yoff_ll, pi_ll=pi_ll, z_ll=z_ll, theta_ll=theta_ll, piprior_ll=piprior_ll, Bprior_ll=Bprior_ll, muprior_ll=muprior_ll, Sigmaprior_ll=Sigmaprior_ll)#
  sum(component_lls)#
}#
dens <- sum(network, na.rm=TRUE)/(N^2 - N)#
b0=1#
a0=(b0*(10*dens))/(1-(10*dens))#
#
postprob=rep(NA,nrow(mcmc_samples$beta))#
for(ii in 1:nrow(mcmc_samples$beta)){#
	mcmc_samples_tmp <- list(beta=rbind(mcmc_samples$beta[ii,]),#
                sigma=rbind(mcmc_samples$sigma[ii,]),#
                 pi=rbind(mcmc_samples$pi[ii,]),#
                 mu=rbind(mcmc_samples$mu[ii,]),#
                 Sigma=abind(mcmc_samples$Sigma[ii,,], along=1),#
                 B=abind(mcmc_samples$B[ii,,],along=1),#
                 Z=abind(mcmc_samples$Z[ii,,], along=1),#
                 gamma=rbind(mcmc_samples$gamma[ii,]))#
	par_t<-mcmc_samples_tmp#
if(ii%%100==0){print(ii)}#
postprob[ii]=log_likelihood(network,mcmc_samples_tmp,alpha0=.1, a0=a0, b0=b0, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1)#
}
hist(postprob)
plot(density(postprob))
mode(postprob)
library(MCMCglmm)
install.packages("MCMCglmm")
library(MCMCglmm)
posterior.mode
postdens=density(postprob)
postmode=which.max(postdens)
postmode=which.max(postdens$y)
postmode
mcmc_samples=list(beta=rbind(mcmc_samples$beta[postmode,]),#
                sigma=rbind(mcmc_samples$sigma[postmode,]),#
                 pi=rbind(mcmc_samples$pi[postmode,]),#
                 mu=rbind(mcmc_samples$mu[postmode,]),#
                 Sigma=abind(mcmc_samples$Sigma[postmode,,], along=1),#
                 B=abind(mcmc_samples$B[postmode,,],along=1),#
                 Z=abind(mcmc_samples$Z[postmode,,], along=1),#
                 gamma=rbind(mcmc_samples$gamma[postmode,]))
require(plyr)#
nsamp <- nrow(mcmc_samples$beta)
Z <- ldply(1:N, function(memb) {#
  tab <- table(mcmc_samples$gamma[,memb])/nsamp#
  this_blocks <- as.numeric(names(tab)[tab > .00017]) ### has appeared in a block at least twice .00017#
#print(this_blocks)#
ldply(this_blocks, function(block) {#
    df <- data.frame(mcmc_samples$Z[mcmc_samples$gamma[,memb] == block,memb,])#
    names(df) <- paste0("Z", 1:2)#
    df$block <- block#
    df$node <- memb#
    return(df)#
  })#
})
mcmc_samples$gamma
Z
nsamp
memb=1
table(mcmc_samples$gamma[,memb])
table(mcmc_samples$gamma[,memb])/nsamp
N
Z <- ldply(1:N, function(memb) {#
  tab <- table(mcmc_samples$gamma[,memb])/nsamp#
  this_blocks <- as.numeric(names(tab)[tab > .00017]) ### has appeared in a block at least
tab <- table(mcmc_samples$gamma[,memb])/nsamp#
  this_blocks <- as.numeric(names(tab)[tab > .00017])
this_blocks
block=this_blocks
data.frame(mcmc_samples$Z[mcmc_samples$gamma[,memb] == block,memb,])
dim(mcmc_samples$Z)
require(plyr)#
nsamp <- nrow(mcmc_samples$beta)#
Z <- ldply(1:N, function(memb) {#
  tab <- table(mcmc_samples$gamma[,memb])/nsamp#
  this_blocks <- as.numeric(names(tab)[tab > .00017]) ### has appeared in a block at least twice .00017#
#print(this_blocks)#
ldply(this_blocks, function(block) {#
    df <- data.frame(mcmc_samples$Z[mcmc_samples$gamma[,memb] == block,memb])#
    names(df) <- paste0("Z", 1:2)#
    df$block <- block#
    df$node <- memb#
    return(df)#
  })#
})
rm(block)
require(plyr)#
nsamp <- nrow(mcmc_samples$beta)#
Z <- ldply(1:N, function(memb) {#
  tab <- table(mcmc_samples$gamma[,memb])/nsamp#
  this_blocks <- as.numeric(names(tab)[tab > .00017]) ### has appeared in a block at least twice .00017#
#print(this_blocks)#
ldply(this_blocks, function(block) {#
    df <- data.frame(mcmc_samples$Z[mcmc_samples$gamma[,memb] == block,memb])#
    #names(df) <- paste0("Z", 1:2)#
    #df$block <- block#
    #df$node <- memb#
    return(df)#
  })#
})
dim(mcmc_samples$gamma)
ldply(this_blocks, function(block) {#
    df <- data.frame(mcmc_samples$Z[mcmc_samples$gamma[memb] == block,memb])#
    #names(df) <- paste0("Z", 1:2)#
    #df$block <- block#
    #df$node <- memb#
    return(df)#
  })
require(plyr)#
nsamp <- nrow(mcmc_samples$beta)#
Z <- ldply(1:N, function(memb) {#
  tab <- table(mcmc_samples$gamma[,memb])/nsamp#
  this_blocks <- as.numeric(names(tab)[tab > .00017]) ### has appeared in a block at least twice .00017#
#print(this_blocks)#
ldply(this_blocks, function(block) {#
    df <- data.frame(mcmc_samples$Z[mcmc_samples$gamma[memb] == block,memb])#
    #names(df) <- paste0("Z", 1:2)#
    #df$block <- block#
    #df$node <- memb#
    return(df)#
  })#
})
memb
tab <- table(mcmc_samples$gamma[,memb])/nsamp
this_blocks <- as.numeric(names(tab)[tab > .00017]) ### has appeared in a block at least twice .00017
mcmc_samples$gamma[memb]
mcmc_samples$gamma
require(plyr)#
nsamp <- nrow(mcmc_samples$beta)#
Z <- ldply(1:N, function(memb) {#
  tab <- table(mcmc_samples$gamma[memb])/nsamp#
  this_blocks <- as.numeric(names(tab)[tab > .00017]) ### has appeared in a block at least twice .00017#
#print(this_blocks)#
ldply(this_blocks, function(block) {#
    df <- data.frame(mcmc_samples$Z[mcmc_samples$gamma[memb] == block,memb])#
    #names(df) <- paste0("Z", 1:2)#
    #df$block <- block#
    #df$node <- memb#
    return(df)#
  })#
})
ldply(this_blocks, function(block) {#
    df <- data.frame(mcmc_samples$Z[mcmc_samples$gamma[memb] == block,memb])#
    #names(df) <- paste0("Z", 1:2)#
    #df$block <- block#
    #df$node <- memb#
    return(df)#
  })
nrow(mcmc_samples$beta)
table(mcmc_samples$gamma)
memb=293
sum(table(mcmc_samples$gamma))
mcmc_samples$Z[mcmc_samples$gamma[memb]
== block,memb]
this_blocks
this_blocks <- as.numeric(names(tab)[tab > .00017]) ### has appeared in a block at least twice .00017
block=this_blocks
mcmc_samples$Z[mcmc_samples$gamma[memb] == block,memb]
memb
dim(mcmc_samples$Z)
mcmc_samples$gamma[memb] == block
mcmc_samples$gamma
df<-data.frame(mcmc_samples$Z,mcmc_samples$gamma,1:nrow(mcmc_samples$gamma))
dim(df)
# ################################################################################
# # Multi-resolution blockmodel#
# ##
# # file: indian_village_figures.R#
# # #
# # This file makes the plots for the paper.  Assuming that we have already run India_village_estimation.R#
# ## and have results and have post-processed them with India_village_postprocess.R.  #
# ##
# ##
# # Author: tedwestling#
# ################################################################################
 rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))#
#
#now do some mcmc checks with the "monitor" function from stan#
#note that this assumes you have at least two chains#
#separate arrays for analyzing convergence#
#note the first argument takes the form iterations, chains, paramters#
require(rstan)#
#set this based on the number of chains you've run#
howmanychains=4#
beta_array=array(dim=c(dim(mcmc_samplesc1$beta)[1],howmanychains,dim(mcmc_samplesc1$beta)[2]))#
beta_array[,1,]<-mcmc_samplesc1$beta#
beta_array[,2,]<-mcmc_samplesc2$beta#
beta_array[,3,]<-mcmc_samplesc3$beta#
beta_array[,4,]<-mcmc_samplesc4$beta#
#
sigma_array=array(dim=c(dim(mcmc_samplesc1$sigma)[1],howmanychains,dim(mcmc_samplesc1$sigma)[2]))#
sigma_array[,1,]<-mcmc_samplesc1$sigma#
sigma_array[,2,]<-mcmc_samplesc2$sigma#
sigma_array[,3,]<-mcmc_samplesc3$sigma#
sigma_array[,4,]<-mcmc_samplesc4$sigma#
pi_array=array(dim=c(dim(mcmc_samplesc1$pi)[1],howmanychains,dim(mcmc_samplesc1$pi)[2]))#
pi_array[,1,]<-mcmc_samplesc1$pi#
pi_array[,2,]<-mcmc_samplesc2$pi#
pi_array[,3,]<-mcmc_samplesc3$pi#
pi_array[,4,]<-mcmc_samplesc4$pi#
#
mu_array=array(dim=c(dim(mcmc_samplesc1$mu)[1],howmanychains,dim(mcmc_samplesc1$mu)[2]))#
mu_array[,1,]<-mcmc_samplesc1$mu#
mu_array[,2,]<-mcmc_samplesc2$mu#
mu_array[,3,]<-mcmc_samplesc3$mu#
mu_array[,4,]<-mcmc_samplesc4$mu#
#
Sigma_array=array(dim=c(dim(mcmc_samplesc1$Sigma)[1],howmanychains,4))#
Sigma_array[,1,]<-matrix(mcmc_samplesc1$Sigma,dim(mcmc_samplesc1$Sigma)[1],4)#
Sigma_array[,2,]<-matrix(mcmc_samplesc2$Sigma,dim(mcmc_samplesc2$Sigma)[1],4)#
Sigma_array[,3,]<-matrix(mcmc_samplesc3$Sigma,dim(mcmc_samplesc3$Sigma)[1],4)#
Sigma_array[,4,]<-matrix(mcmc_samplesc4$Sigma,dim(mcmc_samplesc4$Sigma)[1],4)#
#note there are 30 for 6 blocks (6*6-6 on the diagonal)#
B_array=array(dim=c(dim(mcmc_samplesc1$B)[1],howmanychains,((Khat*Khat)-Khat)))#
B_array[,1,]<-matrix(mcmc_samplesc1$B[is.na(mcmc_samplesc1$B)==F],dim(mcmc_samplesc1$B)[1],((Khat*Khat)-Khat))#
B_array[,2,]<-matrix(mcmc_samplesc2$B[is.na(mcmc_samplesc1$B)==F],dim(mcmc_samplesc2$B)[1],((Khat*Khat)-Khat))#
B_array[,3,]<-matrix(mcmc_samplesc3$B[is.na(mcmc_samplesc1$B)==F],dim(mcmc_samplesc3$B)[1],((Khat*Khat)-Khat))#
B_array[,4,]<-matrix(mcmc_samplesc4$B[is.na(mcmc_samplesc1$B)==F],dim(mcmc_samplesc4$B)[1],((Khat*Khat)-Khat))#
#
gamma_array=array(dim=c(dim(mcmc_samplesc1$gamma)[1],howmanychains,dim(mcmc_samplesc1$gamma)[2]))#
gamma_array[,1,]<-mcmc_samplesc1$gamma#
gamma_array[,2,]<-mcmc_samplesc2$gamma#
gamma_array[,3,]<-mcmc_samplesc3$gamma#
gamma_array[,4,]<-mcmc_samplesc4$gamma#
#
# #uncomment to see monitor results#
# #comment to supress if just re-making plots#
# #monitor(B_array)#
# #monitor(Sigma_array)#
# #monitor(mu_array)#
# #monitor(pi_array)#
# #monitor(sigma_array)#
# #monitor(beta_array)#
#
# prefix="plots/"#
# ###make trace plots#
# #mu#
# pdf(file=paste(prefix,"mutrace.pdf",sep=''),height=10,width=6)#
# par(mfrow=c(2,1))#
# matplot(mu_array[-c(1:max(nburn)),,1],type='l',main="Traceplot for mu1",xlab="iteration",ylab="mu1")#
# matplot(mu_array[-c(1:max(nburn)),,2],type='l',main="Traceplot for mu2",xlab="iteration",ylab="mu2")#
# dev.off()#
# pdf(file=paste(prefix,"betatrace.pdf",sep=''),height=10,width=6)#
# par(mfrow=c(3,2))#
# matplot(beta_array[-c(1:max(nburn)),,1],type='l',main="Traceplot for beta1",xlab="iteration",ylab="beta1")#
# matplot(beta_array[-c(1:max(nburn)),,2],type='l',main="Traceplot for beta2",xlab="iteration",ylab="beta2")#
# matplot(beta_array[-c(1:max(nburn)),,3],type='l',main="Traceplot for beta3",xlab="iteration",ylab="beta3")#
# matplot(beta_array[-c(1:max(nburn)),,4],type='l',main="Traceplot for beta4",xlab="iteration",ylab="beta4")#
# matplot(beta_array[-c(1:max(nburn)),,5],type='l',main="Traceplot for beta5",xlab="iteration",ylab="beta5")#
# if(Khat==6){matplot(beta_array[-c(1:max(nburn)),,6],type='l',main="Traceplot for beta6",xlab="iteration",ylab="beta6")}#
# dev.off()#
#
# pdf(file=paste(prefix,"sigmatrace.pdf",sep=''),height=10,width=6)#
# par(mfrow=c(3,2))#
# matplot(sigma_array[-c(1:max(nburn)),,1],type='l',main="Traceplot for sigma1",xlab="iteration",ylab="sigma1")#
# matplot(sigma_array[-c(1:max(nburn)),,2],type='l',main="Traceplot for sigma2",xlab="iteration",ylab="sigma2")#
# matplot(sigma_array[-c(1:max(nburn)),,3],type='l',main="Traceplot for sigma3",xlab="iteration",ylab="sigma3")#
# matplot(sigma_array[-c(1:max(nburn)),,4],type='l',main="Traceplot for sigma4",xlab="iteration",ylab="sigma4")#
# matplot(sigma_array[-c(1:max(nburn)),,5],type='l',main="Traceplot for sigma5",xlab="iteration",ylab="sigma5")#
# if(Khat==6){matplot(sigma_array[-c(1:max(nburn)),,6],type='l',main="Traceplot for sigma6",xlab="iteration",ylab="sigma6")}#
# dev.off()#
# pdf(file=paste(prefix,"pitrace.pdf",sep=''),height=10,width=6)#
# par(mfrow=c(3,2))#
# matplot(pi_array[-c(1:max(nburn)),,1],type='l',main="Traceplot for pi1",xlab="iteration",ylab="pi1")#
# matplot(pi_array[-c(1:max(nburn)),,2],type='l',main="Traceplot for pi2",xlab="iteration",ylab="pi2")#
# matplot(pi_array[-c(1:max(nburn)),,3],type='l',main="Traceplot for pi3",xlab="iteration",ylab="pi3")#
# matplot(pi_array[-c(1:max(nburn)),,4],type='l',main="Traceplot for pi4",xlab="iteration",ylab="pi4")#
# matplot(pi_array[-c(1:max(nburn)),,5],type='l',main="Traceplot for pi5",xlab="iteration",ylab="pi5")#
# if(Khat==6){matplot(pi_array[-c(1:max(nburn)),,6],type='l',main="Traceplot for pi6",xlab="iteration",ylab="pi6")}#
# dev.off()#
# pdf(file=paste(prefix,"Sigmatrace.pdf",sep=''),height=10,width=6)#
# par(mfrow=c(2,2))#
# matplot(Sigma_array[-c(1:max(nburn)),,1],type='l',main="Traceplot for Sigma1",xlab="iteration",ylab="Sigma1")#
# matplot(Sigma_array[-c(1:max(nburn)),,2],type='l',main="Traceplot for Sigma2",xlab="iteration",ylab="Sigma2")#
# matplot(Sigma_array[-c(1:max(nburn)),,3],type='l',main="Traceplot for Sigma3",xlab="iteration",ylab="Sigma3")#
# matplot(Sigma_array[-c(1:max(nburn)),,4],type='l',main="Traceplot for Sigma4",xlab="iteration",ylab="Sigma4")#
# dev.off()#
#
set.seed(47676728)#
# # # CODE FOR COMPUTING JOINT POSTERIOR MODE:#
# gamma_vecs <- apply(mcmc_samples$gamma,1,paste0, collapse='.')#
# gamma_tab <- table(gamma_vecs)#
# head(sort(gamma_tab))#
# # If the maximum of gamma_tab is 1 then no membership appeared more than once and the marginal mode should be used instead#
# gamma_mode <- names(gamma_tab)[which.max(gamma_tab)]#
# joint_mode <- as.numeric(strsplit(gamma_mode, ".", fixed=TRUE)[[1]])#
#
# # CODE FOR COMPUTING MARGINAL POSTERIOR MODES:#
# marg_mode <- as.numeric(apply(mcmc_samples$gamma, 2, function(memb) names(table(memb))[which.max(table(memb))]))#
#
# # CHOOSE ONE FOR DISPLAYING POSITIONS#
# gamma_mode <- marg_mode#
#
# # Plot blocked adjacency matrix - Figure 1#
# png(paste(prefix,'blocked_adjacency.png',sep=''), width=2, height=2, units='in', res=300)#
# plot_blocked_matrix(network, gamma_mode, sort=FALSE)#
# dev.off()#
#hhold <- read.dta('data/indian_village_raw/2. Demographics and Outcomes/household_characteristics.dta')#
#
hhold<-read.dta("/Users/tylermccormick/Dropbox/git_to_work/net_comp_thry/data/indian_village_raw/2. Demographics and Outcomes/household_characteristics.dta")#
#
hhold <- subset(hhold, village==vilno)#
######################################################shaded by probabilty within each block#
######################################################begin of changes#
######################################################begin of changes#
######################################################begin of changes#
######################################################begin of changes#
######################################################begin of changes#
######################################################begin of changes#
######################################################begin of changes#
######################################################begin of changes#
######################################################begin of changes#
######################################################begin of changes#
require(plyr)#
nsamp <- nrow(mcmc_samples$beta)#
Z <- ldply(1:N, function(memb) {#
  tab <- table(mcmc_samples$gamma[,memb])/nsamp#
  this_blocks <- as.numeric(names(tab)[tab > .00017]) ### has appeared in a block at least twice .00017#
#print(this_blocks)#
ldply(this_blocks, function(block) {#
    df <- data.frame(mcmc_samples$Z[mcmc_samples$gamma[,memb] == block,memb,])#
    names(df) <- paste0("Z", 1:2)#
    df$block <- block#
    df$node <- memb#
    return(df)#
  })#
})#
#
all_mean_df <- NULL#
all_edge_df <- NULL#
for(k in 1:K) {#
  nodes_in <- unique(Z$node[Z$block == k])#
  edges <- which(network[nodes_in,nodes_in]==1, arr.ind=TRUE)#
  samples_df <- subset(Z, block==k & !is.na(Z1) & node %in% nodes_in)#
####in the next line ted's code had 10000, changed to nsamp.  NEED TO DOUBLE CHECK THIS!!#
  mean_df <- ddply(samples_df, .(node), function(subdf) data.frame(Z1=mean(subdf$Z1), Z2=mean(subdf$Z2), prob=nrow(subdf)/nsamp))#
  mean_df$Block <- k#
  all_mean_df <- rbind(all_mean_df, mean_df)#
  edge_df <- data.frame(x=mean_df$Z1[edges[,1]], xend=mean_df$Z1[edges[,2]], y=mean_df$Z2[edges[,1]], yend=mean_df$Z2[edges[,2]], prob=(mean_df$prob[edges[,1]]+mean_df$prob[edges[,2]])/2,send=edges[,1],rec=edges[,2])#
  if(nrow(edges) != 0) edge_df$Block <- k#
  all_edge_df <- rbind(all_edge_df, edge_df)#
}#
#
###set up for plot by caste#
hhold$castesubcaste <- as.character(hhold$castesubcaste)#
names(hhold)[3] <- "node"#
#merge the covariate information with the block and latent positions#
all_mean_df2 <- merge(hhold, all_mean_df, all.y = TRUE )#
all_mean_df2$castesubcaste[is.na(all_mean_df2$castesubcaste)] <- "Unknown"#
all_mean_df2$leader[is.na(all_mean_df2$leader)] <- "Unknown"#
#
###truncate to only plot nodes with >40pct post prob of being in block#
all_mean_df2_tr=all_mean_df2[all_mean_df2$prob>.3,]#
########################
#set up indicators of how many blocks a person is in#
bshape=rep(NA,nrow(all_mean_df2_tr))#
nshows=table(all_mean_df2_tr$node)#
for(nn in 1:length(bshape)){#
	ntmp=all_mean_df2_tr$node[nn]#
	bshape[nn]<-nshows[names(nshows)==as.character(ntmp)]#
}#
#
#all_mean_df2_tr<-cbind(all_mean_df2_tr,as.factor(bshape))#
all_mean_df2_tr<-cbind(all_mean_df2_tr,(bshape))#
names(all_mean_df2_tr)[24]<-"bshape"#
rm(bshape)#
#
appearmany=all_mean_df2_tr[all_mean_df2_tr$bshape>=2,]#
all_mean_df2_tr<-all_mean_df2_tr[all_mean_df2_tr$bshape<2,]#
#
appearkeep=NULL#
for(u in unique(appearmany$node)){#
	tmp=appearmany[appearmany$node==u,]#
	appearkeep=rbind(appearkeep,tmp[which.max(tmp$prob),])#
}#
all_mean_df2_tr<-rbind(all_mean_df2_tr,appearkeep)
names(all_mean_df2_tr)
# ################################################################################
# # Multi-resolution blockmodel#
# ##
# # file: indian_village_figures.R#
# # #
# # This file makes the plots for the paper.  Assuming that we have already run India_village_estimation.R#
# ## and have results and have post-processed them with India_village_postprocess.R.  #
# ##
# ##
# # Author: tedwestling#
# ################################################################################
 rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))#
#
#block_latent_MCMC <- function(Y, D, K, burn_in, n_samples, thin, v, epsilon=.1, rZ=1, Atheta=matrix(c(2,1,1,1), nrow=2), alpha0=.1, a0=NULL, b0=NULL, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1, verbose=TRUE, memb_start=NULL, plot_init=FALSE, likelihood=FALSE, true_gamma=NULL, postprocess=TRUE, sample_membs=TRUE, record_acc_probs=FALSE, debug_output=FALSE, perturb_init=TRUE) {#
	#log_likelihood=function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {#
log_likelihood <- function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {#
  K <- length(par_t$pi)#
  d <- ncol(par_t$Z)#
  cD <- 2 * gamma((d+1)/2) / gamma(d/2)#
  pi_ll <- sum(par_t$block_n * log(par_t$pi))#
  Yoff_ll <- sum(par_t$s[lower.tri(par_t$s, diag=FALSE)] * log(par_t$B[lower.tri(par_t$B, diag=FALSE)]))#
  theta <- cbind(as.vector(par_t$beta), as.vector(log(par_t$sigma)))#
  theta_ll <- - K * log(2*3.1415)- (K/2) * log(det(par_t$Sigma)) + sum(apply(theta, 1, function(thetak) - .5 * (thetak - par_t$mu) %*% solve(par_t$Sigma) %*% t(thetak - par_t$mu)))#
  Ydiag_ll <- z_ll <- 0#
  for(k in 1:K) {#
    k_membs <- which(par_t$gamma == k) #
    etak <- par_t$beta[k] - par_t$dists[[k]]#
    mat <- Y[k_membs, k_membs] * etak - log1p(exp(etak))#
    Ydiag_ll <- Ydiag_ll + sum(mat[lower.tri(mat, diag=FALSE)]) #
    z_ll <- z_ll+ sum(dnorm(c(par_t$Z[k_membs,]), 0, par_t$sigma[k], log=TRUE))#
  }#
  piprior_ll <- sum(log(ddirichlet(par_t$pi, rep(alpha0, K))))#
  Bprior_ll <- sum(log(dbeta(par_t$B[lower.tri(par_t$B, diag=FALSE)], a0, b0)))#
  muprior_ll <- - log(2*3.1415) - (1/2) * log(det(par_t$Sigma/ s0)) - (1/2) * (par_t$mu - m0) %*% solve(par_t$Sigma / s0) %*% t(par_t$mu - m0)#
  Sigmaprior_ll <- log(diwish(par_t$Sigma, nu0, psi0))#
  component_lls=c(Ydiag_ll=Ydiag_ll, Yoff_ll=Yoff_ll, pi_ll=pi_ll, z_ll=z_ll, theta_ll=theta_ll, piprior_ll=piprior_ll, Bprior_ll=Bprior_ll, muprior_ll=muprior_ll, Sigmaprior_ll=Sigmaprior_ll)#
  sum(component_lls)#
}#
dens <- sum(network, na.rm=TRUE)/(N^2 - N)#
b0=1#
a0=(b0*(10*dens))/(1-(10*dens))#
#
postprob=rep(NA,nrow(mcmc_samples$beta))#
for(ii in 1:nrow(mcmc_samples$beta)){#
	mcmc_samples_tmp <- list(beta=rbind(mcmc_samples$beta[ii,]),#
                sigma=rbind(mcmc_samples$sigma[ii,]),#
                 pi=rbind(mcmc_samples$pi[ii,]),#
                 mu=rbind(mcmc_samples$mu[ii,]),#
                 Sigma=abind(mcmc_samples$Sigma[ii,,], along=1),#
                 B=abind(mcmc_samples$B[ii,,],along=1),#
                 Z=abind(mcmc_samples$Z[ii,,], along=1),#
                 gamma=rbind(mcmc_samples$gamma[ii,]))#
	par_t<-mcmc_samples_tmp#
if(ii%%100==0){print(ii)}#
postprob[ii]=log_likelihood(network,mcmc_samples_tmp,alpha0=.1, a0=a0, b0=b0, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1)#
}#
#
postdens=density(postprob)#
postmode=which.max(postdens$y)#
#
mcmc_samplespm=list(beta=rbind(mcmc_samples$beta[postmode,]),#
                sigma=rbind(mcmc_samples$sigma[postmode,]),#
                 pi=rbind(mcmc_samples$pi[postmode,]),#
                 mu=rbind(mcmc_samples$mu[postmode,]),#
                 Sigma=abind(mcmc_samples$Sigma[postmode,,], along=1),#
                 B=abind(mcmc_samples$B[postmode,,],along=1),#
                 Z=abind(mcmc_samples$Z[postmode,,], along=1),#
                 gamma=rbind(mcmc_samples$gamma[postmode,]))
all_mean_df2_tr<-cbind(c(1:length(mcmc_samplespm$gamma)),mcmc_samplespm$Z)
head(all_mean_df2_tr)
all_mean_df2_tr<-cbind(c(1:length(mcmc_samplespm$gamma)),mcmc_samplespm$Z,mcmc_samplespm$gamma)
mcmc_samplespm$gamma
mcmc_samplespm$Z
all_mean_df2_tr<-cbind(c(1:length(mcmc_samplespm$gamma)),mcmc_samplespm$Z,mcmc_samplespm$gamma)
dim(mcmc_samplespm$Z)
length(mcmc_samplespm$gamma)
length(c(1:length(mcmc_samplespm$gamma)))
all_mean_df2_tr<-cbind(c(1:length(mcmc_samplespm$gamma)),mcmc_samplespm$Z,as.vector(mcmc_samplespm$gamma))
names(all_mean_df2_tr)<-c("node","Z1","Z2","Block")
vilno
hhold<-read.dta("/Users/tylermccormick/Dropbox/git_to_work/net_comp_thry/data/indian_village_raw/2. Demographics and Outcomes/household_characteristics.dta")#
#
hhold <- subset(hhold, village==vilno)
all_mean_df2_tr<-cbind(c(1:length(mcmc_samplespm$gamma)),mcmc_samplespm$Z,as.vector(mcmc_samplespm$gamma),rep(1,length(mcmc_samplespm$gamma)))#
names(all_mean_df2_tr)<-c("node","Z1","Z2","Block","prob")
all_mean_df<-cbind(c(1:length(mcmc_samplespm$gamma)),mcmc_samplespm$Z,as.vector(mcmc_samplespm$gamma),rep(1,length(mcmc_samplespm$gamma)))#
names(all_mean_df)<-c("node","Z1","Z2","Block","prob")
hhold<-read.dta("/Users/tylermccormick/Dropbox/git_to_work/net_comp_thry/data/indian_village_raw/2. Demographics and Outcomes/household_characteristics.dta")#
hhold <- subset(hhold, village==vilno)#
hhold$castesubcaste <- as.character(hhold$castesubcaste)
names(hhold)[3] <- "node"
all_mean_df2 <- merge(hhold, all_mean_df, all.y = TRUE )
all_mean_df2$castesubcaste[is.na(all_mean_df2$castesubcaste)] <- "Unknown"
all_mean_df2$leader[is.na(all_mean_df2$leader)] <- "Unknown"
all_mean_df2_tr=all_mean_df2
all_edge_df_tr <- NULL
K
for(k in 1:K) {#
  nodes_in <- unique(all_mean_df2_tr$node[all_mean_df2_tr$Block == k])#
  edges <- which(network[nodes_in,nodes_in]==1, arr.ind=TRUE)#
  samples_df <- subset(Z, block==k & !is.na(Z1) & node %in% nodes_in)#
#edge_df_tr <- data.frame(x=all_mean_df2_tr$Z1[edges[,1]], xend=all_mean_df2_tr$Z1[edges[,2]], y=all_mean_df2_tr$Z2[edges[,1]], yend=all_mean_df2_tr$Z2[edges[,2]], prob=(all_mean_df2_tr$prob[edges[,1]]+all_mean_df2_tr$prob[edges[,2]])/2)#
	mean_df <- ddply(samples_df, .(node), function(subdf) data.frame(Z1=mean(subdf$Z1), Z2=mean(subdf$Z2), prob=nrow(subdf)/nsamp))#
 edge_df_tr <- data.frame(x=mean_df$Z1[edges[,1]], xend=mean_df$Z1[edges[,2]], y=mean_df$Z2[edges[,1]], yend=mean_df$Z2[edges[,2]], prob=(mean_df$prob[edges[,1]]+mean_df$prob[edges[,2]])/2,send=edges[,1],rec=edges[,2])#
  if(nrow(edges) != 0) edge_df_tr$Block <- k#
  all_edge_df_tr <- rbind(all_edge_df_tr, edge_df_tr)#
}
k=1
nodes_in <- unique(all_mean_df2_tr$node[all_mean_df2_tr$Block == k])
edges <- which(network[nodes_in,nodes_in]==1, arr.ind=TRUE)
Z
samples_df <- subset(all_mean_df, block==k & !is.na(Z1) & node %in% nodes_in)
head(all_mean_df)
names(all_mean_df)<-c("node","Z1","Z2","Block","prob")
head(all_mean_df)
colnames(all_mean_df)<-c("node","Z1","Z2","Block","prob")
head(all_mean_df)
samples_df <- subset(all_mean_df, Block==k & !is.na(Z1) & node %in% nodes_in)
Z=data.frame(all_mean_df)
head(Z)
samples_df <- subset(Z, Block==k & !is.na(Z1) & node %in% nodes_in)
mean_df <- ddply(samples_df, .(node), function(subdf) data.frame(Z1=mean(subdf$Z1), Z2=mean(subdf$Z2), prob=nrow(subdf)/nsamp))
edge_df_tr <- data.frame(x=mean_df$Z1[edges[,1]], xend=mean_df$Z1[edges[,2]], y=mean_df$Z2[edges[,1]], yend=mean_df$Z2[edges[,2]], prob=(mean_df$prob[edges[,1]]+mean_df$prob[edges[,2]])/2,send=edges[,1],rec=edges[,2])
if(nrow(edges) != 0) edge_df_tr$Block <- k#
  all_edge_df_tr <- rbind(all_edge_df_tr, edge_df_tr)
all_edge_df_tr <- NULL#
for(k in 1:K) {#
  nodes_in <- unique(all_mean_df2_tr$node[all_mean_df2_tr$Block == k])#
  edges <- which(network[nodes_in,nodes_in]==1, arr.ind=TRUE)#
  samples_df <- subset(Z, Block==k & !is.na(Z1) & node %in% nodes_in)#
#edge_df_tr <- data.frame(x=all_mean_df2_tr$Z1[edges[,1]], xend=all_mean_df2_tr$Z1[edges[,2]], y=all_mean_df2_tr$Z2[edges[,1]], yend=all_mean_df2_tr$Z2[edges[,2]], prob=(all_mean_df2_tr$prob[edges[,1]]+all_mean_df2_tr$prob[edges[,2]])/2)#
	mean_df <- ddply(samples_df, .(node), function(subdf) data.frame(Z1=mean(subdf$Z1), Z2=mean(subdf$Z2), prob=nrow(subdf)/nsamp))#
 edge_df_tr <- data.frame(x=mean_df$Z1[edges[,1]], xend=mean_df$Z1[edges[,2]], y=mean_df$Z2[edges[,1]], yend=mean_df$Z2[edges[,2]], prob=(mean_df$prob[edges[,1]]+mean_df$prob[edges[,2]])/2,send=edges[,1],rec=edges[,2])#
  if(nrow(edges) != 0) edge_df_tr$Block <- k#
  all_edge_df_tr <- rbind(all_edge_df_tr, edge_df_tr)#
}
block_names <- list(#
  '1'="Block 1",#
  '2'="Block 2",#
  '3'="Block 3",#
  '4'="Block 4",#
    '5'="Block 5",#
  '6'="Block 6"#
)#
block_labeller <- function(variable,value){#
  return(block_names[value])#
}
prefix="/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks"
(g<-ggplot(all_mean_df2_tr) + #
  geom_segment(data=all_edge_df_tr, aes(x=x, xend=xend, y=y, yend=yend, alpha=prob/2)) +#
  guides(alpha=FALSE)+#
  geom_point(aes(Z1, Z2, size=prob,color=as.factor(castesubcaste),shape=as.factor(castesubcaste))) +#
	scale_size_continuous(range = c(1,4))+#
  #geom_point(aes(Z1, Z2, size=prob,color=as.factor(castesubcaste),shape=bshape)) +#
  guides(cex=FALSE)+ #
  geom_vline(xintercept=0,linetype=2,color="grey64")+#
  geom_hline(yintercept=0,linetype=2,color="grey64")+#
  #geom_text(aes(label=node, x=Z1, y=Z2, size=prob)) + #
  theme_bw() +#
  facet_wrap(~Block, nrow=2, scales='free',labeller=block_labeller) +#
  #labs(x="First latent dimension",y="Second latent dimension")+#
  coord_fixed(ratio=1) + #
 scale_color_manual(name="HH Caste", values=c(1:6), labels=c("General", "Minority", "OBC", "Schedule caste", "Schedule tribe", "Unknown")) +#
 scale_shape_manual(name="HH Caste", values=c(15:20), labels=c("General", "Minority", "OBC", "Schedule caste", "Schedule tribe", "Unknown")) +#
theme(axis.title=element_blank(), panel.grid=element_blank(), strip.background=element_blank()))#
#theme(axis.text=element_blank(), axis.ticks=element_blank(), axis.title=element_blank(), panel.grid=element_blank(), strip.background=element_blank()))
all_mean_df2_tr
head(all_mean_df2)
head(all_mean_df2_tr)
all_mean_df<-cbind(c(1:length(mcmc_samplespm$gamma)),mcmc_samplespm$Z,as.vector(mcmc_samplespm$gamma),rep(1,length(mcmc_samplespm$gamma)))#
colnames(all_mean_df)<-c("node","Z1","Z2","Block","prob")#
Z=data.frame(all_mean_df)#
hhold<-read.dta("/Users/tylermccormick/Dropbox/git_to_work/net_comp_thry/data/indian_village_raw/2. Demographics and Outcomes/household_characteristics.dta")#
hhold <- subset(hhold, village==vilno)#
hhold$castesubcaste <- as.character(hhold$castesubcaste)#
names(hhold)[3] <- "node"#
#merge the covariate information with the block and latent positions#
all_mean_df2 <- merge(hhold, all_mean_df, all.y = TRUE )#
all_mean_df2$castesubcaste[is.na(all_mean_df2$castesubcaste)] <- "Unknown"#
all_mean_df2$leader[is.na(all_mean_df2$leader)] <- "Unknown"#
all_mean_df2_tr=all_mean_df2
head("all_mean_df2_tr")
head(all_mean_df2_tr)
# ################################################################################
# # Multi-resolution blockmodel#
# ##
# # file: indian_village_figures.R#
# # #
# # This file makes the plots for the paper.  Assuming that we have already run India_village_estimation.R#
# ## and have results and have post-processed them with India_village_postprocess.R.  #
# ##
# ##
# # Author: tedwestling#
# ################################################################################
 rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))#
#
#block_latent_MCMC <- function(Y, D, K, burn_in, n_samples, thin, v, epsilon=.1, rZ=1, Atheta=matrix(c(2,1,1,1), nrow=2), alpha0=.1, a0=NULL, b0=NULL, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1, verbose=TRUE, memb_start=NULL, plot_init=FALSE, likelihood=FALSE, true_gamma=NULL, postprocess=TRUE, sample_membs=TRUE, record_acc_probs=FALSE, debug_output=FALSE, perturb_init=TRUE) {#
	#log_likelihood=function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {#
log_likelihood <- function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {#
  K <- length(par_t$pi)#
  d <- ncol(par_t$Z)#
  cD <- 2 * gamma((d+1)/2) / gamma(d/2)#
  pi_ll <- sum(par_t$block_n * log(par_t$pi))#
  Yoff_ll <- sum(par_t$s[lower.tri(par_t$s, diag=FALSE)] * log(par_t$B[lower.tri(par_t$B, diag=FALSE)]))#
  theta <- cbind(as.vector(par_t$beta), as.vector(log(par_t$sigma)))#
  theta_ll <- - K * log(2*3.1415)- (K/2) * log(det(par_t$Sigma)) + sum(apply(theta, 1, function(thetak) - .5 * (thetak - par_t$mu) %*% solve(par_t$Sigma) %*% t(thetak - par_t$mu)))#
  Ydiag_ll <- z_ll <- 0#
  for(k in 1:K) {#
    k_membs <- which(par_t$gamma == k) #
    etak <- par_t$beta[k] - par_t$dists[[k]]#
    mat <- Y[k_membs, k_membs] * etak - log1p(exp(etak))#
    Ydiag_ll <- Ydiag_ll + sum(mat[lower.tri(mat, diag=FALSE)]) #
    z_ll <- z_ll+ sum(dnorm(c(par_t$Z[k_membs,]), 0, par_t$sigma[k], log=TRUE))#
  }#
  piprior_ll <- sum(log(ddirichlet(par_t$pi, rep(alpha0, K))))#
  Bprior_ll <- sum(log(dbeta(par_t$B[lower.tri(par_t$B, diag=FALSE)], a0, b0)))#
  muprior_ll <- - log(2*3.1415) - (1/2) * log(det(par_t$Sigma/ s0)) - (1/2) * (par_t$mu - m0) %*% solve(par_t$Sigma / s0) %*% t(par_t$mu - m0)#
  Sigmaprior_ll <- log(diwish(par_t$Sigma, nu0, psi0))#
  component_lls=c(Ydiag_ll=Ydiag_ll, Yoff_ll=Yoff_ll, pi_ll=pi_ll, z_ll=z_ll, theta_ll=theta_ll, piprior_ll=piprior_ll, Bprior_ll=Bprior_ll, muprior_ll=muprior_ll, Sigmaprior_ll=Sigmaprior_ll)#
  sum(component_lls)#
}#
dens <- sum(network, na.rm=TRUE)/(N^2 - N)#
b0=1#
a0=(b0*(10*dens))/(1-(10*dens))#
#
postprob=rep(NA,nrow(mcmc_samples$beta))#
for(ii in 1:nrow(mcmc_samples$beta)){#
	mcmc_samples_tmp <- list(beta=rbind(mcmc_samples$beta[ii,]),#
                sigma=rbind(mcmc_samples$sigma[ii,]),#
                 pi=rbind(mcmc_samples$pi[ii,]),#
                 mu=rbind(mcmc_samples$mu[ii,]),#
                 Sigma=abind(mcmc_samples$Sigma[ii,,], along=1),#
                 B=abind(mcmc_samples$B[ii,,],along=1),#
                 Z=abind(mcmc_samples$Z[ii,,], along=1),#
                 gamma=rbind(mcmc_samples$gamma[ii,]))#
	par_t<-mcmc_samples_tmp#
if(ii%%100==0){print(ii)}#
postprob[ii]=log_likelihood(network,mcmc_samples_tmp,alpha0=.1, a0=a0, b0=b0, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1)#
}#
#
postdens=density(postprob)#
postmode=which.max(postdens$y)#
#
mcmc_samplespm=list(beta=rbind(mcmc_samples$beta[postmode,]),#
                sigma=rbind(mcmc_samples$sigma[postmode,]),#
                 pi=rbind(mcmc_samples$pi[postmode,]),#
                 mu=rbind(mcmc_samples$mu[postmode,]),#
                 Sigma=abind(mcmc_samples$Sigma[postmode,,], along=1),#
                 B=abind(mcmc_samples$B[postmode,,],along=1),#
                 Z=abind(mcmc_samples$Z[postmode,,], along=1),#
                 gamma=rbind(mcmc_samples$gamma[postmode,]))#
all_mean_df<-cbind(c(1:length(mcmc_samplespm$gamma)),mcmc_samplespm$Z,as.vector(mcmc_samplespm$gamma),rep(1,length(mcmc_samplespm$gamma)))#
colnames(all_mean_df)<-c("node","Z1","Z2","Block","prob")#
Z=data.frame(all_mean_df)#
hhold<-read.dta("/Users/tylermccormick/Dropbox/git_to_work/net_comp_thry/data/indian_village_raw/2. Demographics and Outcomes/household_characteristics.dta")#
hhold <- subset(hhold, village==vilno)#
hhold$castesubcaste <- as.character(hhold$castesubcaste)#
names(hhold)[3] <- "node"#
#merge the covariate information with the block and latent positions#
all_mean_df2 <- merge(hhold, all_mean_df, all.y = TRUE )#
all_mean_df2$castesubcaste[is.na(all_mean_df2$castesubcaste)] <- "Unknown"#
all_mean_df2$leader[is.na(all_mean_df2$leader)] <- "Unknown"#
all_mean_df2_tr=all_mean_df2#
#
all_edge_df_tr <- NULL#
for(k in 1:K) {#
  nodes_in <- unique(all_mean_df2_tr$node[all_mean_df2_tr$Block == k])#
  edges <- which(network[nodes_in,nodes_in]==1, arr.ind=TRUE)#
  samples_df <- subset(Z, Block==k & !is.na(Z1) & node %in% nodes_in)#
#edge_df_tr <- data.frame(x=all_mean_df2_tr$Z1[edges[,1]], xend=all_mean_df2_tr$Z1[edges[,2]], y=all_mean_df2_tr$Z2[edges[,1]], yend=all_mean_df2_tr$Z2[edges[,2]], prob=(all_mean_df2_tr$prob[edges[,1]]+all_mean_df2_tr$prob[edges[,2]])/2)#
	mean_df <- ddply(samples_df, .(node), function(subdf) data.frame(Z1=mean(subdf$Z1), Z2=mean(subdf$Z2), prob=nrow(subdf)/nsamp))#
 edge_df_tr <- data.frame(x=mean_df$Z1[edges[,1]], xend=mean_df$Z1[edges[,2]], y=mean_df$Z2[edges[,1]], yend=mean_df$Z2[edges[,2]], prob=(mean_df$prob[edges[,1]]+mean_df$prob[edges[,2]])/2,send=edges[,1],rec=edges[,2])#
  if(nrow(edges) != 0) edge_df_tr$Block <- k#
  all_edge_df_tr <- rbind(all_edge_df_tr, edge_df_tr)#
}
# ################################################################################
# # Multi-resolution blockmodel#
# ##
# # file: indian_village_figures.R#
# # #
# # This file makes the plots for the paper.  Assuming that we have already run India_village_estimation.R#
# ## and have results and have post-processed them with India_village_postprocess.R.  #
# ##
# ##
# # Author: tedwestling#
# ################################################################################
 rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))#
#
#block_latent_MCMC <- function(Y, D, K, burn_in, n_samples, thin, v, epsilon=.1, rZ=1, Atheta=matrix(c(2,1,1,1), nrow=2), alpha0=.1, a0=NULL, b0=NULL, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1, verbose=TRUE, memb_start=NULL, plot_init=FALSE, likelihood=FALSE, true_gamma=NULL, postprocess=TRUE, sample_membs=TRUE, record_acc_probs=FALSE, debug_output=FALSE, perturb_init=TRUE) {#
	#log_likelihood=function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {#
log_likelihood <- function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {#
  K <- length(par_t$pi)#
  d <- ncol(par_t$Z)#
  cD <- 2 * gamma((d+1)/2) / gamma(d/2)#
  pi_ll <- sum(par_t$block_n * log(par_t$pi))#
  Yoff_ll <- sum(par_t$s[lower.tri(par_t$s, diag=FALSE)] * log(par_t$B[lower.tri(par_t$B, diag=FALSE)]))#
  theta <- cbind(as.vector(par_t$beta), as.vector(log(par_t$sigma)))#
  theta_ll <- - K * log(2*3.1415)- (K/2) * log(det(par_t$Sigma)) + sum(apply(theta, 1, function(thetak) - .5 * (thetak - par_t$mu) %*% solve(par_t$Sigma) %*% t(thetak - par_t$mu)))#
  Ydiag_ll <- z_ll <- 0#
  for(k in 1:K) {#
    k_membs <- which(par_t$gamma == k) #
    etak <- par_t$beta[k] - par_t$dists[[k]]#
    mat <- Y[k_membs, k_membs] * etak - log1p(exp(etak))#
    Ydiag_ll <- Ydiag_ll + sum(mat[lower.tri(mat, diag=FALSE)]) #
    z_ll <- z_ll+ sum(dnorm(c(par_t$Z[k_membs,]), 0, par_t$sigma[k], log=TRUE))#
  }#
  piprior_ll <- sum(log(ddirichlet(par_t$pi, rep(alpha0, K))))#
  Bprior_ll <- sum(log(dbeta(par_t$B[lower.tri(par_t$B, diag=FALSE)], a0, b0)))#
  muprior_ll <- - log(2*3.1415) - (1/2) * log(det(par_t$Sigma/ s0)) - (1/2) * (par_t$mu - m0) %*% solve(par_t$Sigma / s0) %*% t(par_t$mu - m0)#
  Sigmaprior_ll <- log(diwish(par_t$Sigma, nu0, psi0))#
  component_lls=c(Ydiag_ll=Ydiag_ll, Yoff_ll=Yoff_ll, pi_ll=pi_ll, z_ll=z_ll, theta_ll=theta_ll, piprior_ll=piprior_ll, Bprior_ll=Bprior_ll, muprior_ll=muprior_ll, Sigmaprior_ll=Sigmaprior_ll)#
  sum(component_lls)#
}#
dens <- sum(network, na.rm=TRUE)/(N^2 - N)#
b0=1#
a0=(b0*(10*dens))/(1-(10*dens))#
#
postprob=rep(NA,nrow(mcmc_samples$beta))#
for(ii in 1:nrow(mcmc_samples$beta)){#
	mcmc_samples_tmp <- list(beta=rbind(mcmc_samples$beta[ii,]),#
                sigma=rbind(mcmc_samples$sigma[ii,]),#
                 pi=rbind(mcmc_samples$pi[ii,]),#
                 mu=rbind(mcmc_samples$mu[ii,]),#
                 Sigma=abind(mcmc_samples$Sigma[ii,,], along=1),#
                 B=abind(mcmc_samples$B[ii,,],along=1),#
                 Z=abind(mcmc_samples$Z[ii,,], along=1),#
                 gamma=rbind(mcmc_samples$gamma[ii,]))#
	par_t<-mcmc_samples_tmp#
if(ii%%100==0){print(ii)}#
postprob[ii]=log_likelihood(network,mcmc_samples_tmp,alpha0=.1, a0=a0, b0=b0, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1)#
}#
#
postdens=density(postprob)#
postmode=which.max(postdens$y)#
#
mcmc_samplespm=list(beta=rbind(mcmc_samples$beta[postmode,]),#
                sigma=rbind(mcmc_samples$sigma[postmode,]),#
                 pi=rbind(mcmc_samples$pi[postmode,]),#
                 mu=rbind(mcmc_samples$mu[postmode,]),#
                 Sigma=abind(mcmc_samples$Sigma[postmode,,], along=1),#
                 B=abind(mcmc_samples$B[postmode,,],along=1),#
                 Z=abind(mcmc_samples$Z[postmode,,], along=1),#
                 gamma=rbind(mcmc_samples$gamma[postmode,]))#
all_mean_df<-cbind(c(1:length(mcmc_samplespm$gamma)),mcmc_samplespm$Z,as.vector(mcmc_samplespm$gamma),rep(1,length(mcmc_samplespm$gamma)))#
colnames(all_mean_df)<-c("node","Z1","Z2","Block","prob")#
Z=data.frame(all_mean_df)#
hhold<-read.dta("/Users/tylermccormick/Dropbox/git_to_work/net_comp_thry/data/indian_village_raw/2. Demographics and Outcomes/household_characteristics.dta")#
hhold <- subset(hhold, village==vilno)#
hhold$castesubcaste <- as.character(hhold$castesubcaste)#
names(hhold)[3] <- "node"#
#merge the covariate information with the block and latent positions#
all_mean_df2 <- merge(hhold, all_mean_df, all.y = TRUE )#
all_mean_df2$castesubcaste[is.na(all_mean_df2$castesubcaste)] <- "Unknown"#
all_mean_df2$leader[is.na(all_mean_df2$leader)] <- "Unknown"#
all_mean_df2_tr=all_mean_df2#
#
all_edge_df_tr <- NULL#
for(k in 1:K) {#
  nodes_in <- unique(all_mean_df2_tr$node[all_mean_df2_tr$Block == k])#
  edges <- which(network[nodes_in,nodes_in]==1, arr.ind=TRUE)#
  samples_df <- subset(Z, Block==k & !is.na(Z1) & node %in% nodes_in)#
#edge_df_tr <- data.frame(x=all_mean_df2_tr$Z1[edges[,1]], xend=all_mean_df2_tr$Z1[edges[,2]], y=all_mean_df2_tr$Z2[edges[,1]], yend=all_mean_df2_tr$Z2[edges[,2]], prob=(all_mean_df2_tr$prob[edges[,1]]+all_mean_df2_tr$prob[edges[,2]])/2)#
	mean_df <- ddply(samples_df, .(node), function(subdf) data.frame(Z1=mean(subdf$Z1), Z2=mean(subdf$Z2), prob=nrow(subdf)))#
 edge_df_tr <- data.frame(x=mean_df$Z1[edges[,1]], xend=mean_df$Z1[edges[,2]], y=mean_df$Z2[edges[,1]], yend=mean_df$Z2[edges[,2]], prob=(mean_df$prob[edges[,1]]+mean_df$prob[edges[,2]])/2,send=edges[,1],rec=edges[,2])#
  if(nrow(edges) != 0) edge_df_tr$Block <- k#
  all_edge_df_tr <- rbind(all_edge_df_tr, edge_df_tr)#
}
block_names <- list(#
  '1'="Block 1",#
  '2'="Block 2",#
  '3'="Block 3",#
  '4'="Block 4",#
    '5'="Block 5",#
  '6'="Block 6"#
)#
block_labeller <- function(variable,value){#
  return(block_names[value])#
}
head(all_edge_df_tr)
head(all_mean_df2_tr)
(g<-ggplot(all_mean_df2_tr) + #
  geom_segment(data=all_edge_df_tr, aes(x=x, xend=xend, y=y, yend=yend, alpha=prob/2)) +#
  guides(alpha=FALSE)+#
  geom_point(aes(Z1, Z2, size=prob,color=as.factor(castesubcaste),shape=as.factor(castesubcaste))) +#
	scale_size_continuous(range = c(1,4))+#
  #geom_point(aes(Z1, Z2, size=prob,color=as.factor(castesubcaste),shape=bshape)) +#
  guides(cex=FALSE)+ #
  geom_vline(xintercept=0,linetype=2,color="grey64")+#
  geom_hline(yintercept=0,linetype=2,color="grey64")+#
  #geom_text(aes(label=node, x=Z1, y=Z2, size=prob)) + #
  theme_bw() +#
  facet_wrap(~Block, nrow=2, scales='free',labeller=block_labeller) +#
  #labs(x="First latent dimension",y="Second latent dimension")+#
  coord_fixed(ratio=1) + #
 scale_color_manual(name="HH Caste", values=c(1:6), labels=c("General", "Minority", "OBC", "Schedule caste", "Schedule tribe", "Unknown")) +#
 scale_shape_manual(name="HH Caste", values=c(15:20), labels=c("General", "Minority", "OBC", "Schedule caste", "Schedule tribe", "Unknown")) +#
theme(axis.title=element_blank(), panel.grid=element_blank(), strip.background=element_blank()))#
#theme(axis.text=element_blank(), axis.ticks=element_blank(), axis.title=element_blank(), panel.grid=element_blank(), strip.background=element_blank()))
# ################################################################################
# # Multi-resolution blockmodel#
# ##
# # file: indian_village_figures.R#
# # #
# # This file makes the plots for the paper.  Assuming that we have already run India_village_estimation.R#
# ## and have results and have post-processed them with India_village_postprocess.R.  #
# ##
# ##
# # Author: tedwestling#
# ################################################################################
 rm(list = ls())#
#set your working directory to the top level multiresolution_networks folder#
#setwd("")#
setwd("/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks")#
source("header.R")#
load("data/results/village_59_mcmc_strongass_v1_postprocessed.Rdata")#
#
require(abind)#
#assuming here that we've done no burn-in on the sampling, so removing first 1k iterations#
nburn=c(1:(length(chain1$mu[,1])*.25))#
#
#all the samples combined together for analysis later#
mcmc_samples <- list(beta=rbind(mcmc_samplesc1$beta[-nburn,], mcmc_samplesc2$beta[-nburn,],mcmc_samplesc3$beta[-nburn,], mcmc_samplesc4$beta[-nburn,]),#
                sigma=rbind(mcmc_samplesc1$sigma[-nburn,], mcmc_samplesc2$sigma[-nburn,], mcmc_samplesc3$sigma[-nburn,], mcmc_samplesc4$sigma[-nburn,]),#
                 pi=rbind(mcmc_samplesc1$pi[-nburn,], mcmc_samplesc2$pi[-nburn,], mcmc_samplesc3$pi[-nburn,], mcmc_samplesc4$pi[-nburn,]),#
                 mu=rbind(mcmc_samplesc1$mu[-nburn,], mcmc_samplesc2$mu[-nburn,], mcmc_samplesc3$mu[-nburn,], mcmc_samplesc4$mu[-nburn,]),#
                 Sigma=abind(mcmc_samplesc1$Sigma[-nburn,,], mcmc_samplesc2$Sigma[-nburn,,], mcmc_samplesc3$Sigma[-nburn,,], mcmc_samplesc4$Sigma[-nburn,,], along=1),#
                 B=abind(mcmc_samplesc1$B[-nburn,,], mcmc_samplesc2$B[-nburn,,], mcmc_samplesc3$B[-nburn,,], mcmc_samplesc4$B[-nburn,,], along=1),#
                 Z=abind(mcmc_samplesc1$Z[-nburn,,], mcmc_samplesc2$Z[-nburn,,], mcmc_samplesc3$Z[-nburn,,], mcmc_samplesc4$Z[-nburn,,], along=1),#
                 gamma=rbind(mcmc_samplesc1$gamma[-nburn,], mcmc_samplesc2$gamma[-nburn,], mcmc_samplesc3$gamma[-nburn,], mcmc_samplesc4$gamma[-nburn,]))#
#
#block_latent_MCMC <- function(Y, D, K, burn_in, n_samples, thin, v, epsilon=.1, rZ=1, Atheta=matrix(c(2,1,1,1), nrow=2), alpha0=.1, a0=NULL, b0=NULL, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1, verbose=TRUE, memb_start=NULL, plot_init=FALSE, likelihood=FALSE, true_gamma=NULL, postprocess=TRUE, sample_membs=TRUE, record_acc_probs=FALSE, debug_output=FALSE, perturb_init=TRUE) {#
	#log_likelihood=function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {#
log_likelihood <- function(Y, par_t, alpha0, a0, b0, m0, s0, psi0, nu0) {#
  K <- length(par_t$pi)#
  d <- ncol(par_t$Z)#
  cD <- 2 * gamma((d+1)/2) / gamma(d/2)#
  pi_ll <- sum(par_t$block_n * log(par_t$pi))#
  Yoff_ll <- sum(par_t$s[lower.tri(par_t$s, diag=FALSE)] * log(par_t$B[lower.tri(par_t$B, diag=FALSE)]))#
  theta <- cbind(as.vector(par_t$beta), as.vector(log(par_t$sigma)))#
  theta_ll <- - K * log(2*3.1415)- (K/2) * log(det(par_t$Sigma)) + sum(apply(theta, 1, function(thetak) - .5 * (thetak - par_t$mu) %*% solve(par_t$Sigma) %*% t(thetak - par_t$mu)))#
  Ydiag_ll <- z_ll <- 0#
  for(k in 1:K) {#
    k_membs <- which(par_t$gamma == k) #
    etak <- par_t$beta[k] - par_t$dists[[k]]#
    mat <- Y[k_membs, k_membs] * etak - log1p(exp(etak))#
    Ydiag_ll <- Ydiag_ll + sum(mat[lower.tri(mat, diag=FALSE)]) #
    z_ll <- z_ll+ sum(dnorm(c(par_t$Z[k_membs,]), 0, par_t$sigma[k], log=TRUE))#
  }#
  piprior_ll <- sum(log(ddirichlet(par_t$pi, rep(alpha0, K))))#
  Bprior_ll <- sum(log(dbeta(par_t$B[lower.tri(par_t$B, diag=FALSE)], a0, b0)))#
  muprior_ll <- - log(2*3.1415) - (1/2) * log(det(par_t$Sigma/ s0)) - (1/2) * (par_t$mu - m0) %*% solve(par_t$Sigma / s0) %*% t(par_t$mu - m0)#
  Sigmaprior_ll <- log(diwish(par_t$Sigma, nu0, psi0))#
  component_lls=c(Ydiag_ll=Ydiag_ll, Yoff_ll=Yoff_ll, pi_ll=pi_ll, z_ll=z_ll, theta_ll=theta_ll, piprior_ll=piprior_ll, Bprior_ll=Bprior_ll, muprior_ll=muprior_ll, Sigmaprior_ll=Sigmaprior_ll)#
  sum(component_lls)#
}#
dens <- sum(network, na.rm=TRUE)/(N^2 - N)#
b0=1#
a0=(b0*(10*dens))/(1-(10*dens))#
#
postprob=rep(NA,nrow(mcmc_samples$beta))#
for(ii in 1:nrow(mcmc_samples$beta)){#
	mcmc_samples_tmp <- list(beta=rbind(mcmc_samples$beta[ii,]),#
                sigma=rbind(mcmc_samples$sigma[ii,]),#
                 pi=rbind(mcmc_samples$pi[ii,]),#
                 mu=rbind(mcmc_samples$mu[ii,]),#
                 Sigma=abind(mcmc_samples$Sigma[ii,,], along=1),#
                 B=abind(mcmc_samples$B[ii,,],along=1),#
                 Z=abind(mcmc_samples$Z[ii,,], along=1),#
                 gamma=rbind(mcmc_samples$gamma[ii,]))#
	par_t<-mcmc_samples_tmp#
if(ii%%100==0){print(ii)}#
postprob[ii]=log_likelihood(network,mcmc_samples_tmp,alpha0=.1, a0=a0, b0=b0, m0=c(0,0), s0=0.01, psi0=matrix(c(5.1,0,0,5.1), nrow=2), nu0=5.1)#
}#
#
postdens=density(postprob)#
postmode=which.max(postdens$y)#
#
mcmc_samplespm=list(beta=rbind(mcmc_samples$beta[postmode,]),#
                sigma=rbind(mcmc_samples$sigma[postmode,]),#
                 pi=rbind(mcmc_samples$pi[postmode,]),#
                 mu=rbind(mcmc_samples$mu[postmode,]),#
                 Sigma=abind(mcmc_samples$Sigma[postmode,,], along=1),#
                 B=abind(mcmc_samples$B[postmode,,],along=1),#
                 Z=abind(mcmc_samples$Z[postmode,,], along=1),#
                 gamma=rbind(mcmc_samples$gamma[postmode,]))#
all_mean_df<-cbind(c(1:length(mcmc_samplespm$gamma)),mcmc_samplespm$Z,as.vector(mcmc_samplespm$gamma),rep(1,length(mcmc_samplespm$gamma)))#
colnames(all_mean_df)<-c("node","Z1","Z2","Block","prob")#
Z=data.frame(all_mean_df)#
hhold<-read.dta("/Users/tylermccormick/Dropbox/git_to_work/net_comp_thry/data/indian_village_raw/2. Demographics and Outcomes/household_characteristics.dta")#
hhold <- subset(hhold, village==vilno)#
hhold$castesubcaste <- as.character(hhold$castesubcaste)#
names(hhold)[3] <- "node"#
#merge the covariate information with the block and latent positions#
all_mean_df2 <- merge(hhold, all_mean_df, all.y = TRUE )#
all_mean_df2$castesubcaste[is.na(all_mean_df2$castesubcaste)] <- "Unknown"#
all_mean_df2$leader[is.na(all_mean_df2$leader)] <- "Unknown"#
all_mean_df2_tr=all_mean_df2#
#
all_edge_df_tr <- NULL#
for(k in 1:K) {#
  nodes_in <- unique(all_mean_df2_tr$node[all_mean_df2_tr$Block == k])#
  edges <- which(network[nodes_in,nodes_in]==1, arr.ind=TRUE)#
  samples_df <- subset(Z, Block==k & !is.na(Z1) & node %in% nodes_in)#
#edge_df_tr <- data.frame(x=all_mean_df2_tr$Z1[edges[,1]], xend=all_mean_df2_tr$Z1[edges[,2]], y=all_mean_df2_tr$Z2[edges[,1]], yend=all_mean_df2_tr$Z2[edges[,2]], prob=(all_mean_df2_tr$prob[edges[,1]]+all_mean_df2_tr$prob[edges[,2]])/2)#
	mean_df <- ddply(samples_df, .(node), function(subdf) data.frame(Z1=mean(subdf$Z1), Z2=mean(subdf$Z2), prob=nrow(subdf)))#
 edge_df_tr <- data.frame(x=mean_df$Z1[edges[,1]], xend=mean_df$Z1[edges[,2]], y=mean_df$Z2[edges[,1]], yend=mean_df$Z2[edges[,2]], prob=(mean_df$prob[edges[,1]]+mean_df$prob[edges[,2]])/2,send=edges[,1],rec=edges[,2])#
  if(nrow(edges) != 0) edge_df_tr$Block <- k#
  all_edge_df_tr <- rbind(all_edge_df_tr, edge_df_tr)#
}#
#
block_names <- list(#
  '1'="Block 1",#
  '2'="Block 2",#
  '3'="Block 3",#
  '4'="Block 4",#
    '5'="Block 5",#
  '6'="Block 6"#
)#
block_labeller <- function(variable,value){#
  return(block_names[value])#
}#
#
prefix="/Users/tylermccormick/Dropbox/git_to_work/archive/multiresolution_networks"#
#
(g<-ggplot(all_mean_df2_tr) + #
  geom_segment(data=all_edge_df_tr, aes(x=x, xend=xend, y=y, yend=yend, alpha=prob/2)) +#
  guides(alpha=FALSE)+#
  geom_point(aes(Z1, Z2, size=prob,color=as.factor(castesubcaste),shape=as.factor(castesubcaste))) +#
	scale_size_continuous(range = c(1,4))+#
  #geom_point(aes(Z1, Z2, size=prob,color=as.factor(castesubcaste),shape=bshape)) +#
  guides(cex=FALSE)+ #
  geom_vline(xintercept=0,linetype=2,color="grey64")+#
  geom_hline(yintercept=0,linetype=2,color="grey64")+#
  #geom_text(aes(label=node, x=Z1, y=Z2, size=prob)) + #
  theme_bw() +#
  facet_wrap(~Block, nrow=2, scales='free',labeller=block_labeller) +#
  #labs(x="First latent dimension",y="Second latent dimension")+#
  coord_fixed(ratio=1) + #
 scale_color_manual(name="HH Caste", values=c(1:6), labels=c("General", "Minority", "OBC", "Schedule caste", "Schedule tribe", "Unknown")) +#
 scale_shape_manual(name="HH Caste", values=c(15:20), labels=c("General", "Minority", "OBC", "Schedule caste", "Schedule tribe", "Unknown")) +#
theme(axis.title=element_blank(), panel.grid=element_blank(), strip.background=element_blank()))#
#theme(axis.text=element_blank(), axis.ticks=element_blank(), axis.title=element_blank(), panel.grid=element_blank(), strip.background=element_blank()))#
ggsave(paste(prefix,'latent_positions_shadedv2_jointpost.png',sep=''), g, width=6.5, height=3, units='in', scale=1.5)#
######################################################shaded by probabilty#
######################################################end of changes
